# =============================================================================
# PACKAGE METADATA
# =============================================================================
[package]
name = "rust-ai-core"
version = "0.3.1"
edition = "2021"

# Why Rust 1.92?
# - Required for latest language features used by dependencies
# - Ensures users have access to stable async traits and const generics
rust-version = "1.92"

license = "MIT"
authors = ["Tyler Zervas <tz-dev@vectorweight.com>"]
description = "Unified AI engineering toolkit: orchestrates peft-rs, qlora-rs, unsloth-rs, axolotl-rs, bitnet-quantize, trit-vsa, vsa-optim-rs, and tritter-accel"
repository = "https://github.com/tzervas/rust-ai-core"
homepage = "https://github.com/tzervas/rust-ai-core"
documentation = "https://docs.rs/rust-ai-core"
keywords = ["machine-learning", "cuda", "gpu", "fine-tuning", "quantization"]
categories = ["science", "mathematics", "development-tools"]

# =============================================================================
# LIBRARY CONFIGURATION
# =============================================================================
[lib]
# Why both rlib and cdylib?
# - rlib: Standard Rust library format for Rust consumers
# - cdylib: Required for Python extension modules (PyO3)
crate-type = ["rlib", "cdylib"]
name = "rust_ai_core"

# =============================================================================
# CORE DEPENDENCIES
# =============================================================================
[dependencies]
# Candle: Minimalist ML framework by Hugging Face
# Why candle-core?
# - Provides Tensor type and Device abstraction we build upon
# - Lightweight compared to full PyTorch bindings
# - Native Rust, no Python runtime required
# Why default-features = false?
# - Avoids pulling in CUDA by default (user opts in via features)
# - Keeps compilation fast for CPU-only users
candle-core = { version = "0.9", default-features = false }

# Error handling
# Why thiserror?
# - Derive macro for std::error::Error trait
# - Zero runtime cost, compile-time code generation
# - Industry standard for Rust error types
thiserror = "2.0"

# Logging/Tracing
# Why tracing (not log)?
# - Structured logging with spans for async context
# - Better performance characteristics
# - Widely adopted in async Rust ecosystem
tracing = "0.1"

# Why tracing-subscriber?
# - Provides formatters and filters for tracing output
# - env-filter feature enables RUST_LOG environment variable
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

# Half-precision floats
# Why half?
# - Provides f16 and bf16 types for mixed-precision training
# - Required for memory-efficient model loading
# - Used by candle for half-precision tensor support
half = "2.7"

# =============================================================================
# RUST-AI ECOSYSTEM CRATES (REQUIRED)
# =============================================================================
# These crates form the rust-ai ecosystem. rust-ai-core orchestrates them
# into a unified API for AI engineering and development.

# PEFT (Parameter-Efficient Fine-Tuning) adapters
# Why peft-rs?
# - LoRA, DoRA, AdaLoRA, and other adapter implementations
# - Foundation for efficient fine-tuning without full model retraining
peft-rs = "1.0"

# QLoRA (Quantized LoRA) for memory-efficient fine-tuning
# Why qlora-rs?
# - 4-bit quantization with LoRA for massive memory savings
# - Enables fine-tuning large models on consumer GPUs
qlora-rs = "1.0"

# Unsloth-style optimized transformer blocks
# Why unsloth-rs?
# - GPU-optimized attention and feedforward implementations
# - Significant speedups for inference and training
unsloth-rs = "1.0"

# Axolotl-style configurable fine-tuning orchestration
# Why axolotl-rs?
# - YAML-driven configuration for fine-tuning pipelines
# - High-level orchestration of training workflows
axolotl-rs = "1.1"

# BitNet 1.58-bit quantization
# Why bitnet-quantize?
# - Microsoft BitNet b1.58 implementation
# - Extreme compression with ternary weights (-1, 0, +1)
bitnet-quantize = "0.1"

# Ternary Vector Symbolic Architectures
# Why trit-vsa?
# - Balanced ternary arithmetic with bitsliced storage
# - Foundation for VSA-based neural computations
trit-vsa = "0.1"

# VSA-based training optimization
# Why vsa-optim-rs?
# - Deterministic training with VSA compression
# - Closed-form gradient prediction for faster convergence
vsa-optim-rs = "0.1"

# Ternary acceleration layer
# Why tritter-accel?
# - GPU-accelerated ternary operations
# - Bridges BitNet, VSA, and ternary computations
# - v0.1.3 includes rlib support and PyO3 0.27 alignment
tritter-accel = "0.1"

# =============================================================================
# OPTIONAL DEPENDENCIES - GPU SUPPORT
# =============================================================================
# CubeCL: GPU kernel compilation framework
# Why CubeCL?
# - Write GPU kernels in Rust, compile to CUDA/Metal/Vulkan
# - Enables custom CUDA kernels without writing raw CUDA C
# - Provides higher-level abstractions than raw CUDA bindings
cubecl = { version = "0.9", optional = true }
cubecl-cuda = { version = "0.9", optional = true }

# =============================================================================
# OPTIONAL DEPENDENCIES - PYTHON BINDINGS
# =============================================================================
# PyO3: Rust bindings for Python
# Why PyO3?
# - Industry standard for Rust-Python interop
# - Zero-copy data sharing with numpy arrays
# - Supports Python 3.9-3.13
#
# Why version 0.27?
# - Required for compatibility with tritter-accel v0.1.3 which uses pyo3 0.27
# - All ecosystem crates aligned on this version
#
# Why these features?
# - extension-module: Required for building Python extension modules
# - generate-import-lib: Required for Windows cross-compilation without Python installed
pyo3 = { version = "0.27", features = ["extension-module", "generate-import-lib"], optional = true }

# NumPy bindings for PyO3
# Why numpy crate?
# - Provides zero-copy ndarray interop between Rust and Python
# - Version must match PyO3 version for compatibility
numpy = { version = "0.27", optional = true }

# =============================================================================
# DEV DEPENDENCIES
# =============================================================================
[dev-dependencies]
# Criterion: Statistics-driven benchmarking
# Why criterion?
# - Provides statistically rigorous benchmarks
# - Automatic detection of performance regressions
# - HTML reports with graphs
criterion = "0.8"

# Tokio: Async runtime
# Why tokio in dev-dependencies?
# - Required for async tests
# - "full" feature enables all tokio components for testing flexibility
tokio = { version = "1.49", features = ["full"] }

# =============================================================================
# FEATURES
# =============================================================================
[features]
# Default includes all ecosystem crates (they're required dependencies)
# Users can opt-in to CUDA and Python bindings
default = []

# CUDA support
# Why this feature?
# - Enables CUDA acceleration for tensor operations
# - Pulls in CubeCL for custom kernel support
# - Requires NVIDIA GPU and CUDA toolkit
cuda = ["candle-core/cuda", "dep:cubecl", "dep:cubecl-cuda"]

# Python bindings
# Why this feature?
# - Enables Python extension module compilation
# - Only needed when building rust-ai-core-bindings package
# - Rust-only users skip Python toolchain requirement
python = ["dep:pyo3", "dep:numpy"]

# Full feature set (CUDA + Python)
full = ["cuda", "python"]

# =============================================================================
# LINTS
# =============================================================================
[lints.rust]
# Why deny unsafe_code?
# - Forces safe Rust throughout the codebase
# - Prevents subtle memory safety bugs
# - PyO3 handles all necessary unsafe internally
unsafe_code = "deny"

# Why warn missing_docs?
# - Encourages documentation of public API
# - Undocumented code is incomplete code
# - Helps maintainability and onboarding
missing_docs = "warn"

[lints.clippy]
# Why pedantic?
# - Catches subtle bugs and anti-patterns
# - Enforces idiomatic Rust style
# - Some lints are allowed in specific modules where appropriate
pedantic = "warn"

# =============================================================================
# EXAMPLES
# =============================================================================
[[example]]
name = "device_selection"
path = "examples/device_selection.rs"

[[example]]
name = "memory_tracking"
path = "examples/memory_tracking.rs"

[[example]]
name = "error_handling"
path = "examples/error_handling.rs"

# =============================================================================
# BENCHMARKS
# =============================================================================
[[bench]]
name = "core_ops"
# Why harness = false?
# - Criterion provides its own test harness
# - Prevents conflict with built-in benchmark harness
harness = false

