"""Type stubs for rust_ai_core_bindings."""

from __future__ import annotations
from typing import Dict, Any, List

__version__: str

class MemoryTracker:
    """Opaque handle for tracking memory allocations."""
    ...

def estimate_tensor_bytes(shape: List[int], dtype: str = "f32") -> int: ...
def estimate_attention_memory(batch_size: int, num_heads: int, seq_len: int, head_dim: int, dtype: str = "bf16") -> int: ...
def create_memory_tracker(limit_gb: float = 8.0, overhead_factor: float = 1.1) -> MemoryTracker: ...
def tracker_would_fit(tracker: MemoryTracker, bytes: int) -> bool: ...
def tracker_allocate(tracker: MemoryTracker, bytes: int) -> None: ...
def tracker_deallocate(tracker: MemoryTracker, bytes: int) -> None: ...
def tracker_allocated_bytes(tracker: MemoryTracker) -> int: ...
def tracker_peak_bytes(tracker: MemoryTracker) -> int: ...
def tracker_limit_bytes(tracker: MemoryTracker) -> int: ...
def tracker_estimate_with_overhead(tracker: MemoryTracker, shape: List[int], dtype: str = "f32") -> int: ...
def tracker_reset(tracker: MemoryTracker) -> None: ...
def cuda_available() -> bool: ...
def get_device_info(force_cpu: bool = False, cuda_device: int = 0) -> Dict[str, Any]: ...
def bytes_per_dtype(dtype: str) -> int: ...
def is_floating_point_dtype(dtype: str) -> bool: ...
def accumulator_dtype(dtype: str) -> str: ...
def supported_dtypes() -> List[str]: ...
def init_logging(level: str = "info", timestamps: bool = True, ansi: bool = True) -> None: ...
def version() -> str: ...
def default_overhead_factor() -> float: ...
